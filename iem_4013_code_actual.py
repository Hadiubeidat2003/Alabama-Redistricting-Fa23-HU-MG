# -*- coding: utf-8 -*-
"""IEM 4013 Code Actual

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jguXJkdtnuKzUjvVpV5MMDdseFEmsQAA
"""

import Graph

# Specify the file path and name
file_path = 'C:\\Users\\blrod\\Downloads\\districting-data-2020-counties\\'
file_name = 'AL_features.2023.csv'

# Read Alabama county graph from the csv file
graph = Graph.from_json(file_path + file_name)

# Print information about each node
for node in graph.nodes:
    node_info = graph.nodes[node]
    print(f"Node {node} is {node_info['County']}, "
          f"population {node_info['population']} and is centered at "
          f"({node_info['center']['lon']}, {node_info['center']['lat']})")

from gerrychain import Graph
from geopy.distance import geodesic
import gurobipy as gp
from gurobipy import GRB
import math

# Read Alabama county graph from the JSON file
graph = Graph.from_json(file_path + file_name)

# For each node, print the node #, county name, population, and lat-long coordinates
for node in graph.nodes:
    name, population = graph.nodes[node]["NAME20"], graph.nodes[node]['P0010001']
    graph.nodes[node]['TOTPOP'] = population
    graph.nodes[node]['C_X'], graph.nodes[node]['C_Y'] = graph.nodes[node]['INTPTLON20'], graph.nodes[node]['INTPTLAT20']
    print(f"Node {node} is {name} County, which has population {population} and is centered at ({graph.nodes[node]['C_X']}, {graph.nodes[node]['C_Y']})")

# Create distance dictionary
dist = {(i, j): geodesic((graph.nodes[i]['C_Y'], graph.nodes[i]['C_X']),
                         (graph.nodes[j]['C_Y'], graph.nodes[j]['C_X'])).miles
        for i in graph.nodes for j in graph.nodes}

# Set up population deviation parameters
deviation, k = 0.01, 7
total_population = sum(graph.nodes[node]['TOTPOP'] for node in graph.nodes)
L = math.ceil((1 - deviation / 2) * total_population / k)
U = math.floor((1 + deviation / 2) * total_population / k)
print(f"Using L = {L} and U = {U} and k = {k}")

# Create the optimization model and variables
model = gp.Model()
x = model.addVars(graph.nodes, graph.nodes, vtype=GRB.BINARY)

# Objective: Minimize the moment of inertia: sum (d^2 * p * x over all i and j)
model.setObjective(gp.quicksum(dist[i, j] ** 2 * graph.nodes[i]['TOTPOP'] * x[i, j] for i in graph.nodes for j in graph.nodes), GRB.MINIMIZE)

# Constraints: each county i is assigned to one district
model.addConstrs(gp.quicksum(x[i, j] for j in graph.nodes) == 1 for i in graph.nodes)

# Constraint: there should be k district centers
model.addConstr(gp.quicksum(x[j, j] for j in graph.nodes) == k)

# Constraints: if j roots a district, then its population is between L and U
model.addConstrs(gp.quicksum(graph.nodes[i]['TOTPOP'] * x[i, j] for i in graph.nodes) >= L * x[j, j] for j in graph.nodes)
model.addConstrs(gp.quicksum(graph.nodes[i]['TOTPOP'] * x[i, j] for i in graph.nodes) <= U * x[j, j] for j in graph.nodes)

# Coupling constraints: if i is assigned to j, then j is a center
model.addConstrs(x[i, j] <= x[j, j] for i in graph.nodes for j in graph.nodes)

model.update()

import networkx as nx
import gurobipy as gp
from gurobipy import GRB

# Create a directed graph from an existing graph G
DG = nx.DiGraph(G)

# Create a Gurobi model
m = gp.Model()

# Decision variable: x[i, j] is 1 if node i is assigned to node j
x = m.addVars(G.nodes, G.nodes, vtype=GRB.BINARY)

# Contiguity constraints
for i in G.nodes:
    for j in G.nodes:
        if i != j:
            m.addConstr(x.sum(i, '*') - x.sum('*', i) == 1)

# Flow variables
f = m.addVars(DG.edges, G.nodes, name="flow")

# Flow conservation constraints
for i in G.nodes:
    for j in G.nodes:
        if i != j:
            m.addConstr(
                gp.quicksum(f[u, i, j] - f[i, u, j] for u in G.neighbors(i)) == x[i, j]
            )

# Node capacity constraints
M = G.number_of_nodes() - 1
for i in G.nodes:
    for j in G.nodes:
        if i != j:
            m.addConstr(
                gp.quicksum(f[u, i, j] for u in G.neighbors(i)) <= M * x[i, j]
            )

# Node cannot receive flow of its own type
for j in G.nodes:
    m.addConstr(gp.quicksum(f[u, j, j] for u in G.neighbors(j)) == 0)

# Set the objective function (you might need to adjust this part based on your actual objective function)
m.setObjective(gp.quicksum(f) + gp.quicksum(x), GRB.MINIMIZE)

# Optimize the model
m.optimize()

# Print the optimal objective value
print("Optimal Objective Value:", m.objVal)


# Print the objective value
print(m.objVal)

# Retrieve the districts and their populations
centers = [j for j in G.nodes if x[j, j].x > 0.5]
districts = [[i for i in G.nodes if x[i, j].x > 0.5] for j in centers]
district_counties = [[G.nodes[i]["NAME20"] for i in districts[j]] for j in range(k)]
district_populations = [sum(G.nodes[i]["TOTPOP"] for i in districts[j]) for j in range(k)]

# Print district info
for j in range(k):
    print(f"District {j} has population {district_populations[j]} and contains counties {district_counties[j]}\n")

# Draw the districts on a map
import geopandas as gpd

# Read Alabama county shapefile
filepath = 'C:\\Users\\blrod\\Downloads\\districting-data-2020-county\\'
filename = 'AL_county.shp'
df = gpd.read_file(filepath + filename)